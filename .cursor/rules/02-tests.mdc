---
alwaysApply: true
---

## Testing Rules

All rules MANDATORY.

**Philosophy:** "A test that never fails is not a test, it's a lie."

**Framework:** Pest exclusively, `it()` syntax, 70%+ coverage

### Running Tests

```bash
composer pest                 # Full suite with coverage (parallel)
vendor/bin/pest $TEST_FILE    # Specific file
```

### Dependency Injection in Tests

**DI Container rule applies to PRODUCTION code, not tests.**

**Unit Tests (Services/Utilities) - Manual Instantiation:**

```php
$mockFs = mockFilesystem(true, 'content');
$service = new EnvService(new FilesystemService($mockFs), new Dotenv());
```

Clear dependency wiring, easy mocking, no container overhead.

**Command/Integration Tests - Container with Bindings:**

```php
// Basic usage
$container = mockCommandContainer();
$command = $container->build(ServerAddCommand::class);

// Override services
$customSSH = mockSSHServiceWithBehavior(canConnect: false);
$container = mockCommandContainer(ssh: $customSSH);

// Pre-populate data
$container = mockCommandContainer(
    inventoryData: ['servers' => [['name' => 'web1', 'host' => '192.168.1.1']]]
);
```

Sustainable pattern - no updates when BaseCommand grows.

**Container Auto-wiring (Edge Cases Only):**

```php
$container = new Container();
$container->bind(Filesystem::class, $mockFs);
$service = $container->build(CustomService::class);
```

Use when verifying DI configuration or testing service integration.

**Maintenance:** When adding service to BaseCommand, update `mockCommandContainer()` in `tests/TestHelpers.php`:

```php
function mockCommandContainer(
    ?NewService $newService = null,  // 1. Add parameter
    // ... existing params
) {
    $newService = $newService ?? mockNewService();  // 2. Build or use provided
    $container->bind(NewService::class, $newService);  // 3. Bind
}
```

### Test Minimalism

**Target:** Keep test files under 1.8x source code size.

**Rules:**

- Test core business logic only, skip framework testing
- Use datasets: `->with([])` for multiple scenarios
- Eliminate overlap: no two tests covering same functionality
- Consolidate assertions: `expect($x)->toBe(1)->and($y)->toBe(2)`
- Mock external dependencies only
- No performance tests unless performance is primary concern
- Don't sacrifice readability for ratio targets

**Don't consolidate:** Different public methods, exception vs normal flow, different setup, distinct business logic.

### AAA Pattern

```php
it('does something', function () {
    // ARRANGE
    $service = new Service(mock(Dependency::class));

    // ACT
    $result = $service->action();

    // ASSERT
    expect($result)->toBe('expected');

    // CLEANUP (when needed)
    unlink($tempFile);
});
```

Exception tests: `// ACT & ASSERT` when act triggers assertion.

Use `describe()` blocks, `beforeEach()` setup, extract helpers/traits for DRY tests.

### Testing Patterns

**Forbidden:**

```php
expect($x)->toBeInstanceOf(Class::class);   // Type-only testing
expect($x)->toBeArray();                    // Generic assertion
expect($x)->not->toBeNull();                // Meaningless alone
expect($x)->not->toBeNull()->and($x)->toContain('text');  // Redundant
expect(true)->toBeTrue();                   // Literally meaningless
sleep(...);                                 // Test logic not time
```

**Required:**

```php
expect($config->getValue('host'))->toBe('example.com');
expect($this->validator->isValid($input))->toBe($expected);
$mock->shouldReceive('method')->with('param')->andReturn('result');

// For polling/timeout - use zero intervals
$service->waitForReady('id', timeout: 10, pollInterval: 0);
```

### Test Types

**Unit Tests:**

- Mock all external dependencies (filesystem, HTTP, processes)
- Test single units in isolation
- Complete in milliseconds

**Integration Tests:**

- Real file operations and external processes
- CLI commands and full workflows

**Layer Strategy:**

- CLI Commands → Integration tests
- Business Services → Unit tests (mocked dependencies)
- Utilities/Helpers → Unit tests

### Static Analysis

**PHPStan applies to PRODUCTION code, not tests.**

Ignore PHPStan issues in tests. Focus on functionality over compliance. Avoid excessive phpdoc to appease types.
