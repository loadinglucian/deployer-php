---
alwaysApply: true
---

## Symfony Console Rules

All rules MANDATORY. Fix violating code, not these rules.

### Core Principle

Every command MUST be fully runnable non-interactively via CLI options. Every prompt MUST have a corresponding CLI option. Test by running the command with only CLI options (no TTY).

### Output Method Philosophy

NEVER use Symfony IO methods directly - use BaseCommand methods exclusively.

All console output flows through custom methods in BaseCommand for consistent TUI styling.

**Custom IO Methods:**

```php
// Output
$this->out(['Multiple', 'lines']);
$this->hr();
$this->h1('Section Heading');
$this->displayDeets(['Key' => 'value']);

// Status messages
$this->yay('Operation completed');         // ✓ checkmark
$this->nay('Operation failed');            // ✗ red X
$this->warn('Skipping step');              // ! warning
$this->info('Configuration loaded');       // ℹ info
$this->ul(['Item 1', 'Item 2']);           // • bullet list
$this->ol(['Step 1', 'Step 2']);           // 1. numbered list
```

**Missing a method?** Add to BaseCommand with modern styling.

**Integration Points:**

- Base: BaseCommand.php
- Output: ConsoleOutputTrait.php
- Input: ConsoleInputTrait.php
- Methods: `out()`, `hr()`, `h1()`, `info()`, `yay()`, `nay()`, `warn()`, `ul()`, `ol()`, `displayDeets()`, `commandReplay()`, `getOptionOrPrompt()`, `getValidatedOptionOrPrompt()`, `promptText()`, `promptPassword()`, `promptConfirm()`, `promptSelect()`, `promptMultiselect()`, `promptSuggest()`, `promptSearch()`, `promptPause()`, `promptSpin()`

**Trait Organization:**

- ConsoleOutputTrait: Output/formatting methods using `$this->io` (SymfonyStyle)
- ConsoleInputTrait: Input methods using `$this->input` (InputInterface)
- BaseCommand: Shared initialization, configuration, orchestration (NOT individual I/O ops)

### User Input with Laravel Prompts

Use `laravel/prompts` for ALL user interactions:

```php
use function Laravel\Prompts\{text, password, confirm, select, multiselect, suggest, search, spin};

$name = text('What is your name?', required: true);
$password = password('Enter password:', required: true);
$confirmed = confirm('Deploy?', default: false);
$env = select('Environment:', ['dev', 'staging', 'prod']);
$features = multiselect('Features:', ['cache', 'queue', 'logs']);
$result = spin(fn() => $this->service->process(), 'Processing...');
```

Commands handle ALL user interaction. Services return plain data with NO console operations.

### Interactive + Options Pattern

Support both interactive prompts AND CLI options using `getOptionOrPrompt()`.

**Basic Pattern:**

```php
protected function configure(): void {
    parent::configure();
    $this->addOption('name', null, InputOption::VALUE_REQUIRED, 'Server name');
    $this->addOption('environment', null, InputOption::VALUE_REQUIRED, 'Environment');
}

protected function execute(InputInterface $input, OutputInterface $output): int {
    // Text input - checks CLI option first, prompts if not provided
    $name = $this->io->getOptionOrPrompt(
        'name',
        fn () => $this->io->promptText(
            label: 'Server name:',
            placeholder: 'web1',
            required: true
        )
    );

    // Select input
    $env = $this->io->getOptionOrPrompt(
        'environment',
        fn () => $this->io->promptSelect(
            label: 'Environment:',
            options: ['dev', 'staging', 'prod'],
            default: 'prod'
        )
    );

    return Command::SUCCESS;
}
```

**Signature:** `$this->io->getOptionOrPrompt(string $optionName, Closure $promptCallback): mixed`

Prompt wrappers (`$this->io->promptText()`, `$this->io->promptSelect()`, etc.) automatically suppress extra spacing for clean output.

### Input Validation

**Core Principles:**

- Validate everything: CLI options, prompts, and auto-resolved values
- Fail fast: Validate before expensive operations (API calls, SSH connections)
- Never silent fallback: Explicit user input must fail validation, not fall back to defaults
- Complete errors: Include invalid value and guidance

**Validator Signature:**

```php
// Returns ?string: error message if invalid, null if valid
protected function validateNameInput(mixed $value): ?string
{
    if (!is_string($value)) {
        return 'Name must be a string';
    }

    if ('' === trim($value)) {
        return 'Name cannot be empty';
    }

    if (null !== $this->repo->findByName($value)) {
        return "'{$value}' already exists";
    }

    return null;
}
```

**Naming Convention:**

- `validate*Input()` - Returns `?string` (for prompts/options)
- `validate*()` - Throws exceptions (for heavy I/O like git repo checks)

**Usage with getValidatedOptionOrPrompt:**

```php
$name = $this->io->getValidatedOptionOrPrompt(
    'name',
    fn ($validate) => $this->io->promptText(label: 'Name:', validate: $validate),
    fn ($value) => $this->validateNameInput($value)
);

if (null === $name) {
    return Command::FAILURE;  // Validation failed, error already displayed
}
```

**Optional Input with Fallback Resolution:**

```php
// Allow empty to trigger default resolution
protected function validateKeyPathInputAllowEmpty(mixed $path): ?string
{
    if (!is_string($path)) {
        return 'Path must be a string';
    }

    if ('' === trim($path)) {
        return null;  // Allow empty - triggers default
    }

    return $this->validateKeyPathInput($path);  // Non-empty: validate strictly
}

// After validation - only fallback for empty, expand explicit paths
$resolved = ('' === trim($pathRaw))
    ? $this->resolveDefaultPath()       // Fallback resolution
    : $this->fs->expandPath($pathRaw);  // User's explicit path (validated)
```

**Selection from Dynamic Data:**

```php
protected function validateRegion(mixed $region, array $validRegions): ?string
{
    if (!is_string($region)) {
        return 'Region must be a string';
    }

    if (!isset($validRegions[$region])) {
        return "Invalid region: '{$region}' not available";
    }

    return null;
}
```

**Error Message Guidelines:**

- Include invalid value: `"Invalid region: 'xyz1' not available"`
- Provide guidance: `"Port must be 1-65535 (common: 22, 2222)"`
- Show format examples: `"UUID format: 12345678-1234-1234-1234-123456789abc"`

**Common Mistakes:**

```php
// ❌ Missing null check
$value = $this->io->getValidatedOptionOrPrompt(...);
$this->doSomething($value);  // $value could be null!

// ❌ Silent fallback on explicit input
$path = $this->getOptionOrPrompt('key-path', ...);
$resolved = $this->resolveKey($path);  // Falls back even if user's path invalid!

// ❌ CLI option bypasses validation
$env = $this->getOptionOrPrompt('env', fn() => promptSelect(..., options: $valid));
// --env=invalid passes through unvalidated!
```

See: ServerValidationTrait.php, KeyValidationTrait.php

### Boolean Flags

**VALUE_NONE - Simple flags:**

```php
// --yes or -y
$this->addOption('yes', 'y', InputOption::VALUE_NONE, 'Skip confirmation');

$confirmed = $this->io->getOptionOrPrompt(
    'yes',
    fn () => $this->io->promptConfirm('Deploy now?', default: true)
);
```

**VALUE_NEGATABLE - Tri-state flags:**

```php
// --php-default or --no-php-default
$this->addOption('php-default', null, InputOption::VALUE_NEGATABLE, 'Set as default PHP');

// Prompts if neither --flag nor --no-flag provided
$setDefault = $this->io->getOptionOrPrompt(
    'php-default',
    fn () => $this->io->promptConfirm('Set as default?', default: false)
);
```

### Multiselect with Comma-Separated CLI Input

Multiselect prompts return arrays, but CLI options are strings. Handle both:

```php
$this->addOption('databases', null, InputOption::VALUE_REQUIRED, 'Comma-separated databases');

$selected = $this->io->getOptionOrPrompt(
    'databases',
    fn () => $this->io->promptMultiselect(
        label: 'Database servers (optional):',
        options: ['postgresql' => 'PostgreSQL', 'mysql' => 'MySQL', 'mongodb' => 'MongoDB'],
        default: [],
        hint: 'Space to select, Enter to confirm'
    )
);

// Handle both array (from prompt) and string (from CLI option)
if (is_string($selected)) {
    $selected = array_filter(
        array_map(trim(...), explode(',', $selected)),
        static fn (string $item): bool => '' !== $item
    );
}

// Validate CLI-provided values against allowed options
$unknown = array_diff($selected, array_keys($allowedOptions));
if ([] !== $unknown) {
    $this->nay('Unknown options: ' . implode(', ', $unknown));
    return Command::FAILURE;
}
```

### Multi-Path Prompts

When a prompt offers choices leading to different execution paths, create separate options for each path:

```php
// ❌ WRONG - Only one option, can't skip the choice prompt non-interactively
$this->addOption('deploy-key', null, InputOption::VALUE_REQUIRED, 'Path to deploy key');

// ✅ CORRECT - Separate options for each path
$this->addOption('generate-deploy-key', null, InputOption::VALUE_NONE, 'Use server-generated deploy key');
$this->addOption('custom-deploy-key', null, InputOption::VALUE_REQUIRED, 'Path to custom deploy key');
```

Handle the branching logic explicitly:

```php
/** @var bool $generateKey */
$generateKey = $input->getOption('generate-deploy-key');
/** @var string|null $customKeyPath */
$customKeyPath = $input->getOption('custom-deploy-key');

// Check for conflicting options
if ($generateKey && null !== $customKeyPath) {
    $this->nay('Cannot use both --generate-deploy-key and --custom-deploy-key');
    return Command::FAILURE;
}

if ($generateKey) {
    $deployKeyPath = null;  // Use server-generated
} elseif (null !== $customKeyPath) {
    $deployKeyPath = $customKeyPath;  // Use custom
} else {
    // Interactive: prompt for choice, then conditionally prompt for path
    $choice = $this->io->promptSelect(
        label: 'Deploy key:',
        options: [
            'generate' => 'Use server-generated key pair',
            'custom' => 'Use your own key pair',
        ],
        default: 'generate'
    );

    if ('generate' === $choice) {
        $deployKeyPath = null;
    } else {
        $deployKeyPath = $this->io->promptText(
            label: 'Path to private key:',
            placeholder: '~/.ssh/deploy_key',
            required: true
        );
    }
}
```

### Confirmation Patterns

**Simple Confirmation (`--yes`):**

```php
$this->addOption('yes', 'y', InputOption::VALUE_NONE, 'Skip confirmation');

$confirmed = $this->io->getOptionOrPrompt(
    'yes',
    fn () => $this->io->promptConfirm('Are you sure?', default: false)
);

if (!$confirmed) {
    $this->warn('Operation cancelled');
    return Command::SUCCESS;
}
```

**Type-to-Confirm (`--force`) - For destructive operations:**

```php
$this->addOption('force', 'f', InputOption::VALUE_NONE, 'Skip typing confirmation');

/** @var bool $forceSkip */
$forceSkip = $input->getOption('force') ?? false;

if (!$forceSkip) {
    $typedName = $this->io->promptText(
        label: "Type the server name '{$server->name}' to confirm deletion:",
        required: true
    );

    if ($typedName !== $server->name) {
        $this->nay('Name does not match. Operation cancelled.');
        return Command::FAILURE;
    }
}
```

### Post-CLI Validation

When using `getOptionOrPrompt()` (not validated version), validate CLI values explicitly:

```php
$phpVersion = (string) $this->io->getOptionOrPrompt(
    'php-version',
    fn () => $this->io->promptSelect(
        label: 'PHP version:',
        options: $availableVersions,
        default: $defaultVersion
    )
);

// Validate CLI-provided version exists
if (!in_array($phpVersion, $availableVersions, true)) {
    $this->nay(
        "PHP {$phpVersion} not available. Available: " . implode(', ', $availableVersions)
    );
    return Command::FAILURE;
}
```

### Resource Selection Pattern

For selecting from existing resources:

```php
protected function selectServer(): ServerDTO|int
{
    $servers = $this->ensureServersAvailable();
    if (is_int($servers)) {
        return Command::FAILURE;
    }

    $serverNames = array_map(fn (ServerDTO $s) => $s->name, $servers);

    $name = (string) $this->io->getOptionOrPrompt(
        'server',
        fn () => $this->io->promptSelect(
            label: 'Select server:',
            options: $serverNames,
        )
    );

    // Validate CLI-provided name exists
    $server = $this->servers->findByName($name);
    if (null === $server) {
        $this->nay("Server '{$name}' not found in inventory");
        return Command::FAILURE;
    }

    return $server;
}
```

### Command Options & Input

**Naming Convention Rules:**

| Option           | Usage                    | Type             | When                 |
| ---------------- | ------------------------ | ---------------- | -------------------- |
| `--server`       | Select existing server   | `VALUE_REQUIRED` | delete, info, deploy |
| `--domain`       | Select existing site     | `VALUE_REQUIRED` | site operations      |
| `--name`         | Define new resource name | `VALUE_REQUIRED` | add, create          |
| `--host`         | Host/IP address          | `VALUE_REQUIRED` | server config        |
| `--port`         | Port number              | `VALUE_REQUIRED` | server config        |
| `--yes` / `-y`   | Skip confirmation        | `VALUE_NONE`     | all confirmations    |
| `--force` / `-f` | Skip type-to-confirm     | `VALUE_NONE`     | delete commands      |
| `--skip`         | Skip validation          | `VALUE_NONE`     | validation steps     |

**Golden Rule:**

- `--server` / `--domain`: SELECTING existing (operation target)
- `--name`: DEFINING new resource property

Prevents conflicts in commands working with multiple resource types.

**Additional Rules:**

- Use OPTIONS only, never ARGUMENTS (enables `getOptionOrPrompt()`)
- Pair all options with `getOptionOrPrompt()` for dual-mode support
- Boolean flags: `VALUE_NONE` or `VALUE_NEGATABLE`
- Data inputs: `VALUE_REQUIRED`
- Only `--yes` (`-y`) and `--force` (`-f`) get short flags
- Add type annotations on option retrievals: `/** @var bool $flag */`

See: ServerDeleteCommand.php, ServerAddCommand.php

### Command Completion

Always call `commandReplay()` before returning SUCCESS to teach non-interactive usage:

```php
$this->commandReplay('command:name', [
    'option1' => $value1,
    'option2' => $value2,
]);

return Command::SUCCESS;
```

**For conditional options, only include if applicable:**

```php
$replayOptions = [
    'server' => $server->name,
    'php-version' => $phpVersion,
];

if (null !== $deployKeyPath) {
    $replayOptions['custom-deploy-key'] = $deployKeyPath;
} else {
    $replayOptions['generate-deploy-key'] = true;
}

if ($defaultPrompted) {
    $replayOptions['php-default'] = $setDefault;
}

$this->commandReplay('server:install', $replayOptions);
```

Teaches CLI syntax, improves DX, reduces support questions.

**Output:**

```
◆ Run non-interactively:

  vendor/bin/deployer server:delete \
    --server='production-web-01' \
    --yes
```

See: ServerDeleteCommand.php

### Summary Checklist

When building commands, verify:

- [ ] Every prompt has a corresponding `addOption()`
- [ ] Multi-path prompts have separate options for each path
- [ ] Conflicting options are detected and rejected
- [ ] CLI values are validated against allowed options
- [ ] Multiselect handles both array and comma-separated string
- [ ] `commandReplay()` called before SUCCESS return
- [ ] Type annotations on option retrievals (`/** @var bool $flag */`)
