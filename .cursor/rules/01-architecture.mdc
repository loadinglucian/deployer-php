---
alwaysApply: true
---

## Architecture Rules

All rules MANDATORY.

### PHP Standards

- PSR-12, strict types, PHP 8.x features (unions, match, attributes, readonly)
- Explicit return types with generics: `Collection<int, User>`
- Dependency injection via Symfony patterns
- Use Symfony classes over native PHP functions (Filesystem, Process) for testability
- **Yoda conditions:** Always place constants/literals on the LEFT side of comparisons to prevent accidental assignment
- **Always use braces:** ALL control structures (`if`, `else`, `elseif`, `for`, `foreach`, `while`, `do-while`) MUST use curly braces `{ }`, even for single-line bodies

```php
// ✅ CORRECT - Yoda conditions (constant on left)
if (null === $value) { ... }
if ('' === trim($name)) { ... }
if (0 !== $exitCode) { ... }
if ('active' === $status) { ... }
if (null !== $this->repo->find($id)) { ... }

// ❌ WRONG - Variable on left (risk of accidental assignment)
if ($value === null) { ... }
if (trim($name) === '') { ... }
if ($exitCode !== 0) { ... }
if ($status === 'active') { ... }

// Note: Two variables - Yoda doesn't apply
if ($typedName !== $server->name) { ... }
if ($userInput === $expectedValue) { ... }
```

```php
// ✅ CORRECT - Always use braces
if (null === $value) {
    return 'Value is required';
}

foreach ($items as $item) {
    $this->process($item);
}

// ❌ WRONG - Never omit braces
if (null === $value) return 'Value is required';
foreach ($items as $item) $this->process($item);
```

### PHPStan Type Hints

Use `@var` annotations to help PHPStan understand types it cannot infer, not `assert()` in production code.

```php
// ✅ CORRECT - @var annotation (zero runtime impact)
/** @var string $apiToken */
$apiToken = $this->env->get(['API_TOKEN']);

// ❌ WRONG - assert() in production code (runtime cost, can be disabled)
$apiToken = $this->env->get(['API_TOKEN']);
assert(is_string($apiToken));
```

### Imports

Always add `use` statements for vendor packages and project classes. Root namespace FQDNs acceptable (`\InvalidArgumentException`, `\RuntimeException`).

```php
// ✅ CORRECT
use Symfony\Component\Filesystem\Filesystem;
use PHPDeployer\Services\IOService;

$fs = new Filesystem();
throw new \InvalidArgumentException('Error');

// ❌ WRONG - inline FQDNs for non-root namespaces
$fs = new \Symfony\Component\Filesystem\Filesystem();
```

### Dependency Injection System

Use `$container->build(ClassName::class)` for all object creation. Container uses reflection to auto-wire dependencies.

```php
// ✅ CORRECT
$service = $this->container->build(MyService::class);

// ❌ WRONG
$service = new MyService(new Dependency());
```

**Rule:** ALL object creation uses `$container->build()` except DTOs, value objects, pure data structures.

**Container Access:** Constructor injection in production, direct instantiation in tests.

```php
// Production
class SymfonyApp {
    public function __construct(private readonly Container $container) {}
    private function registerCommands(): void {
        $command = $this->container->build(HelloCommand::class);
    }
}

// Tests
$container = new Container();
$service = $container->build(TestService::class);
```

**Test Mocking:** Container supports `bind()` for mock instances:

```php
$container = new Container();
$container->bind(SSHService::class, $mockSSH);
$command = $container->build(ServerAddCommand::class);  // Gets mock
```

**Integration:** Entry point: bin/deployer. Command registration: SymfonyApp.php. Services: Auto-injected via constructor.

### Layer Separation

**Command Layer:**

- Handle user interaction (input/output), orchestrate Services
- NO business logic (delegate to Services)
- NO duplicate orchestration (extract to shared Services)
- Responsible for console styling, error formatting, prompts
- Never invoke other commands (NO proxy commands)

**Service Layer:**

- Atomic, reusable functionality with NO console I/O
- Accept/return plain PHP data types
- Dependency-injected via constructor
- Handle business logic, external APIs, file operations
- Complex orchestration shared by Commands extracted to dedicated Services

**Service State:**

- Stateless: Pure operations, no internal state (validators, calculators, API clients)
- Stateful: Manage configuration/cached data (config loaders, file managers, repositories)
- Stateful services use lazy loading, explicit initialization via public methods (`load()`, `initialize()`), document requirements

**Console I/O:** Only Commands perform console I/O. SymfonyStyle for all output. Services return exceptions/data for Commands to display. See 03-commands.mdc.

**Dependencies:**

- Commands depend on Services
- Services depend on Services/utilities
- All dependencies in constructor signatures
- NO circular dependencies

### Comments

**DocBlock:** Minimalist descriptions, parameters, return types for classes and functions.

**Comment structure:**

```
// ----
// {h1}
// ----

//
// {h2}
// ----

//
// {h3}

// {p}
```

Separate sections visually. One newline between headers/subheaders/paragraphs. No obvious comments. Remove comments when removing code.

### Quality Gates

ALWAYS run before completing task, fix all issues:

```bash
vendor/bin/rector $CHANGED_PHP_FILES   # Code improvements
vendor/bin/pint $CHANGED_PHP_FILES     # Fix style
vendor/bin/phpstan analyze $CHANGED_PHP_FILES_EXCEPT_TESTS  # NEVER run on tests/
```

PHPStan excluded from tests - tests focus on testing functionality over type compliance.
