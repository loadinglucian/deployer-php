---
alwaysApply: true
---

## Playbook Rules

All rules MANDATORY.

### Core Principles

Playbooks are idempotent, non-interactive bash scripts that:

- Execute one or more related tasks
- MUST be idempotent (safe to run multiple times)
- Receive context via environment variables
- Never prompt for user input
- Run completely unattended
- Return parsable YAML output (empty array `[]` if no data)

### Non-Interactive Operation

All playbooks MUST run without user interaction:

- Set `DEBIAN_FRONTEND=noninteractive` for Debian/Ubuntu
- Use `-y` flag for package managers (apt-get, yum)
- Use `-q` flag to suppress unnecessary output
- Use `--batch --yes` for GPG operations
- Use `--quiet` for systemctl where appropriate
- Never use `read`, confirm dialogs, or interactive prompts

### Environment Variables

Use `DEPLOYER_` prefix for all context variables:

```bash
#!/usr/bin/env bash
#
# Install Package
# -------------------------------------------------------------------------------
# Required Environment Variables:
#   DEPLOYER_DISTRO - Distribution (debian|redhat|amazon)
#   DEPLOYER_PERMS  - Permission level (root|sudo)

set -o pipefail
export DEBIAN_FRONTEND=noninteractive

# Validation - errors go to stdout (not YAML = error detected)
if [[ -z $DEPLOYER_DISTRO ]]; then
    echo "Error: DEPLOYER_DISTRO environment variable is required"
    exit 1
fi
```

### Idempotency

ALL playbooks MUST be idempotent - safe to run multiple times without side effects.

Check before acting - don't fail if resource exists:

```bash
# ✅ CORRECT - Idempotent
if ! command -v caddy >/dev/null 2>&1; then
    run_cmd apt-get install -y -q caddy
fi

if [[ ! -d /var/www/app ]]; then
    run_cmd mkdir -p /var/www/app
fi

# ❌ WRONG - Not idempotent (fails on second run)
run_cmd useradd deployer

# ❌ WRONG - Not idempotent (duplicates each run)
echo "export PATH=\$PATH:/usr/local/bin" >> ~/.bashrc
```

Enables recovery, resumption, drift correction.

### Error Handling

Fail fast with clear error messages to stdout. Errors are NOT YAML, so parsing will fail and the error message will be displayed.

```bash
set -o pipefail  # Fail on pipe errors

# Validation errors - output plain text (not YAML)
if [[ -z $DEPLOYER_DISTRO ]]; then
    echo "Error: DEPLOYER_DISTRO environment variable is required"
    exit 1
fi

# Runtime errors - output plain text (not YAML)
if ! command -v required_tool >/dev/null 2>&1; then
    echo "Error: required_tool is not installed"
    exit 1
fi
```

**Key Principle:** Error messages are plain text to stdout. Success results are YAML to stdout. This makes error detection automatic - if YAML parsing fails, it's an error.

### Helper Functions

```bash
# Execute with appropriate permissions
run_cmd() {
    if [[ $DEPLOYER_PERMS == 'root' ]]; then
        "$@"
    else
        sudo "$@"
    fi
}

# Usage
run_cmd apt-get install -y -q package-name
```

### Output

**ALL playbooks MUST return parsable YAML as their final output.**

This is critical for error detection: if YAML parsing fails, we know the playbook encountered an error and can display the raw output as an error message.

**Rules:**

- Final output to stdout MUST be valid YAML
- If no data to return, output empty YAML array: `[]` or empty object: `{}`
- Progress messages during execution go to stderr (use `>&2`)
- YAML output should be the last thing printed to stdout
- Use `✓` for success, `✗` for failure in progress messages

**Example Pattern:**

```bash
# Progress messages to stderr
echo "✓ Processing..." >&2
echo "✓ Task complete" >&2

# Final YAML output to stdout
cat <<EOF
distro: debian
status: success
result: []
EOF
```

**Error Detection Pattern:**

Commands parse playbook output as YAML. If parsing fails, the raw output is an error message to display to the user. This eliminates the need for explicit error codes or special error handling.

### Complete Example

```bash
#!/usr/bin/env bash
set -o pipefail
export DEBIAN_FRONTEND=noninteractive

# Validation
[[ -z $DEPLOYER_DISTRO ]] && echo "Error: DEPLOYER_DISTRO required" && exit 1

# Helpers
run_cmd() { [[ $DEPLOYER_PERMS == 'root' ]] && "$@" || sudo "$@"; }

# Task 1: Install package (idempotent)
if ! command -v nginx >/dev/null 2>&1; then
    run_cmd apt-get install -y -q nginx
    echo "✓ Nginx installed" >&2
else
    echo "✓ Nginx already installed" >&2
fi

# Task 2: Create directory (idempotent)
if [[ ! -d /var/www/app ]]; then
    run_cmd mkdir -p /var/www/app
    echo "✓ Directory created" >&2
else
    echo "✓ Directory already exists" >&2
fi

# Task 3: Configure service (idempotent)
if ! systemctl is-enabled --quiet nginx; then
    run_cmd systemctl enable --quiet nginx
    echo "✓ Nginx enabled" >&2
else
    echo "✓ Nginx already enabled" >&2
fi

echo "✓ Setup complete" >&2

# Output YAML result
cat <<EOF
status: success
nginx_version: $(nginx -v 2>&1 | cut -d/ -f2)
tasks_completed:
  - install_nginx
  - create_directory
  - enable_service
EOF
```

See: server-info.sh
