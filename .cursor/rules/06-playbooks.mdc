---
alwaysApply: true
---

## Playbook Rules

All rules MANDATORY.

### Core Principles

Playbooks are idempotent, non-interactive bash scripts that:

- Execute one or more related tasks
- MUST be idempotent (safe to run multiple times)
- Receive context via environment variables
- Never prompt for user input
- Run completely unattended
- Return parsable YAML output

### Structure

Standard playbook structure using `main()` function:

```bash
#!/usr/bin/env bash
set -o pipefail
export DEBIAN_FRONTEND=noninteractive

# Validation
[[ -z $DEPLOYER_OUTPUT_FILE ]] && echo "Error: DEPLOYER_OUTPUT_FILE required" && exit 1

#
# Helper Functions
# ----
# (see "Helper Functions" section below for run_cmd implementation)

#
# Main Execution
# ----

main() {
    echo "→ Starting..."

    # Tasks go here

    if ! cat > "$DEPLOYER_OUTPUT_FILE" <<EOF; then
status: success
EOF
        echo "Error: Failed to write output file" >&2
        exit 1
    fi
}

main "$@"
```

**Pattern Requirements:**

- Shebang: `#!/usr/bin/env bash`
- Always set `set -o pipefail` (NOT `set -e`)
- Export `DEBIAN_FRONTEND=noninteractive`
- Validate `$DEPLOYER_OUTPUT_FILE` before any work
- Use `main()` function with `main "$@"` at bottom
- Group related functions with comment headers
- Check errors on YAML writes

### Environment Variables

Use `DEPLOYER_` prefix. Standard variables:

- `DEPLOYER_OUTPUT_FILE` - YAML output path (provided automatically)
- `DEPLOYER_DISTRO` - Distribution: `ubuntu|debian` (if needed)
- `DEPLOYER_PERMS` - Permissions: `root|sudo|none` (if needed)

**Validation:**

Detection playbooks only validate `DEPLOYER_OUTPUT_FILE`. Provisioning playbooks additionally validate `DEPLOYER_DISTRO` and `DEPLOYER_PERMS`, then export `DEPLOYER_PERMS` for subshell availability. See Complete Example section for full pattern.

### Distribution Support

Support Ubuntu and Debian only (both use apt package manager). Use `case` statements when Ubuntu/Debian need different package names or configurations:

```bash
# ✅ CORRECT - case statement when distributions differ
case $DEPLOYER_DISTRO in
    ubuntu)
        distro_packages=(software-properties-common)
        run_cmd apt-get install -y "${distro_packages[@]}"
        ;;
    debian)
        distro_packages=(apt-transport-https lsb-release ca-certificates)
        run_cmd apt-get install -y "${distro_packages[@]}"
        ;;
esac

# ❌ WRONG - Unnecessary branching for identical operations
case $DEPLOYER_DISTRO in
    ubuntu|debian)
        run_cmd apt-get update -q  # Same for both!
        run_cmd apt-get install -y -q caddy  # Same for both!
        ;;
esac
```

**Universal operations (no branching needed):**

```bash
run_cmd apt-get update -q
run_cmd apt-get install -y -q caddy
run_cmd systemctl start caddy
run_cmd systemctl enable caddy
run_cmd mkdir -p /var/www/app
```

### Non-Interactive Operation

Never prompt for input. Use non-interactive flags:

- `export DEBIAN_FRONTEND=noninteractive` (always set at top)
- Package managers: `-y -q` flags
- GPG operations: `--batch --yes`
- systemctl: `--quiet` (where appropriate)
- Never use `read`, confirm dialogs, or interactive prompts

### Idempotency

Check before acting. Don't fail if resource already exists:

```bash
# ✅ CORRECT - Idempotent patterns
if ! command -v caddy >/dev/null 2>&1; then
    run_cmd apt-get install -y -q caddy
fi

if [[ ! -d /var/www/app ]]; then
    run_cmd mkdir -p /var/www/app
fi

if ! systemctl is-enabled --quiet caddy; then
    run_cmd systemctl enable --quiet caddy
fi

# For config files that may exist (from packages), check for custom content markers
if ! grep -q "import conf.d/localhost.caddy" /etc/caddy/Caddyfile 2> /dev/null; then
    echo "→ Creating Caddyfile with custom configuration..."
    run_cmd tee /etc/caddy/Caddyfile > /dev/null <<- 'EOF'
        # ... custom config with marker ...
    EOF
fi

# ❌ WRONG - Not idempotent
run_cmd useradd deployer  # Fails second time
echo "export PATH=\$PATH:/usr/local/bin" >> ~/.bashrc  # Duplicates each run

# ❌ WRONG - File existence check when package installs default config
if ! run_cmd test -f /etc/caddy/Caddyfile; then
    # This will never run if package created a default file!
fi
```

### Error Handling

Use `set -o pipefail` but NOT `set -e`. Check exit codes explicitly:

```bash
# Validation errors (before any work) → stdout
[[ -z $DEPLOYER_OUTPUT_FILE ]] && echo "Error: DEPLOYER_OUTPUT_FILE required" && exit 1

# Runtime errors (during execution) → stderr
if ! mkdir -p /var/www/app 2>&1; then
    echo "Error: Failed to create directory" >&2
    exit 1
fi

# Silent checks (expected to sometimes fail)
if ! command -v nginx >/dev/null 2>&1; then
    echo "→ Installing nginx..."
    run_cmd apt-get install -y -q nginx
fi

# Check YAML writes
if ! cat > "$DEPLOYER_OUTPUT_FILE" <<EOF; then
status: success
EOF
    echo "Error: Failed to write output file" >&2
    exit 1
fi
```

**Error Detection:**

If playbook exits before creating `$DEPLOYER_OUTPUT_FILE`, framework treats all output as error message.

### Helper Functions

Standard helper for permission-aware command execution:

```bash
run_cmd() {
    if [[ $DEPLOYER_PERMS == 'root' ]]; then
        "$@"
    else
        sudo -n "$@"
    fi
}
```

The `-n` flag ensures sudo fails fast without prompting for a password, maintaining non-interactive operation.

**Sourcing Shared Helpers:**

Playbooks use shared helper functions from `helpers.sh`. These helpers are automatically inlined when executing playbooks remotely, so playbooks should include a commented source line:

```bash
# Shared helpers are automatically inlined when executing playbooks remotely
# source "$(dirname "$0")/helpers.sh"
```

**Rules:**

- NEVER manually inline helpers into playbook files
- Keep the commented source line for documentation
- Helpers are inlined automatically during remote execution
- The comment pattern allows local testing if needed while documenting the dependency

### Output

Write YAML to `$DEPLOYER_OUTPUT_FILE`. Progress messages to stdout/stderr.

**Pattern:**

```bash
# Action messages (stdout) - indicate what's about to happen
echo "→ Installing packages..."
echo "→ Configuring service..."

# YAML output to file (check for errors)
if ! cat > "$DEPLOYER_OUTPUT_FILE" <<EOF; then
status: success
distro: $DEPLOYER_DISTRO
result: []
EOF
    echo "Error: Failed to write output file" >&2
    exit 1
fi

# Error messages (stderr)
if ! some_command; then
    echo "Error: Command failed" >&2
    exit 1
fi
```

**Action Messages:**

Use `→` (Unicode rightwards arrow U+2192) to indicate an operation is about to start. Messages describe what's about to happen, not what happened. Keep concise and action-oriented. Be explicit: include paths, package names, versions, or identifiers.

```bash
# ✅ CORRECT - Explicit details (path, package name, repository name)
echo "→ Creating /var/www/app directory..."
echo "→ Installing PHP 8.3..."
echo "→ Adding Caddy GPG key..."

# ❌ WRONG - Too generic
echo "→ Creating directory..."
echo "→ Installing package..."
echo "→ Adding key..."

# ✅ CORRECT - Unconditional operations (always run)
echo "→ Updating package lists..."
if ! apt_get_with_retry update; then
    echo "Error: Failed to update package lists" >&2
    exit 1
fi

# ✅ CORRECT - Conditional operations (message INSIDE block, only when needed)
if ! [[ -f /usr/share/keyrings/caddy-stable-archive-keyring.gpg ]]; then
    echo "→ Adding Caddy GPG key..."
    if ! curl -1sLf 'https://example.com/key.gpg' | run_cmd gpg --batch --yes --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg; then
        echo "Error: Failed to add Caddy GPG key" >&2
        exit 1
    fi
fi

# ❌ WRONG - Message outside conditional (shows even when nothing happens)
echo "→ Configuring Caddy repository..."
if ! [[ -f /usr/share/keyrings/caddy-stable-archive-keyring.gpg ]]; then
    # GPG key logic...
fi
```

**Rules:** Be explicit with paths/names/versions. Place messages INSIDE conditional blocks for idempotent operations, OUTSIDE only for operations that always run. Never write progress to output file. See: `playbooks/package-manager.sh`

### Complete Example

```bash
#!/usr/bin/env bash
set -o pipefail
export DEBIAN_FRONTEND=noninteractive

# Validation
[[ -z $DEPLOYER_OUTPUT_FILE ]] && echo "Error: DEPLOYER_OUTPUT_FILE required" && exit 1
[[ -z $DEPLOYER_DISTRO ]] && echo "Error: DEPLOYER_DISTRO required" && exit 1
[[ -z $DEPLOYER_PERMS ]] && echo "Error: DEPLOYER_PERMS required" && exit 1
export DEPLOYER_PERMS

#
# Helper Functions
# ----

run_cmd() {
	if [[ $DEPLOYER_PERMS == 'root' ]]; then
		"$@"
	else
		sudo -n "$@"
	fi
}

#
# Main Execution
# ----

main() {
    local caddy_version

    if ! command -v caddy >/dev/null 2>&1; then
        echo "→ Installing Caddy web server..."
        run_cmd apt-get update -q
        run_cmd apt-get install -y -q caddy
    fi

    if [[ ! -d /var/www/app ]]; then
        echo "→ Creating /var/www/app directory..."
        run_cmd mkdir -p /var/www/app
    fi

    if ! systemctl is-enabled --quiet caddy; then
        echo "→ Enabling Caddy service..."
        run_cmd systemctl enable --quiet caddy
    fi

    caddy_version=$(caddy version 2>&1 | cut -d' ' -f1)

    if ! cat > "$DEPLOYER_OUTPUT_FILE" <<EOF; then
status: success
distro: $DEPLOYER_DISTRO
caddy_version: $caddy_version
tasks_completed:
  - install_caddy
  - create_directory
  - enable_service
EOF
        echo "Error: Failed to write output file" >&2
        exit 1
    fi
}

main "$@"
```

See: `playbooks/server-info.sh`
